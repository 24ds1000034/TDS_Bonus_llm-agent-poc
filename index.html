<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LLM Agent POC â€“ Browser Multi-Tool Reasoning</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body { background: linear-gradient(135deg, #0f172a, #1e293b); color: #e2e8f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    .navbar { background: #111827; }
    .card { background: #0b1220; border: 1px solid #1f2937; border-radius: 12px; }
    .form-control, .form-select { background:#0b1220; color:#e2e8f0; border-color:#1f2937; }
    .btn-primary { background:#2563eb; border-color:#1d4ed8; border-radius: 8px; }
    .btn-outline-light { border-color:#334155; border-radius: 8px; }
    #chat { height: 60vh; overflow-y: auto; padding-right: 6px; }
    .msg { white-space: pre-wrap; border-radius: 8px; }
    .msg.agent { border-left: 4px solid #60a5fa; }
    .msg.user { border-left: 4px solid #34d399; }
    .msg.tool { border-left: 4px solid #f59e0b; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: .925rem; }
    .small-muted { color:#9ca3af; font-size:.9rem; }
    .sticky-input { position: sticky; bottom: 0; background: #0f172a; padding-top: .5rem; }
    .kbd { padding:.1rem .35rem; border:1px solid #475569; border-radius:.35rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .divider { height:1px; background:#1f2937; margin: .75rem 0; }
    .alert-area { position: sticky; top: 0; z-index: 1020; }
    .settings-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: .75rem; }
    code.inline { background:#0b1220; border:1px solid #1f2937; padding:.05rem .35rem; border-radius:.35rem; }
    .logo { width: 20px; height: 20px; vertical-align: -3px; margin-right: 6px; }
  </style>
</head>
<body>
  <nav class="navbar navbar-dark">
    <div class="container-fluid">
      <span class="navbar-brand fw-bold"><img class="logo" src="./assets/logo.svg" alt="">LLM Agent POC</span>
      <div class="d-flex gap-2 align-items-center">
        <select id="provider" class="form-select form-select-sm" style="width: 200px;">
          <option value="openai" selected>OpenAI-compatible</option>
          <option value="openrouter">OpenRouter (compat)</option>
          <option value="perplexity">Perplexity (compat)</option>
          <option value="gemini">Gemini (OpenAI compat)</option>
          <option value="aipipe">AiPipe (OpenAI compat)</option>
          <option value="custom">Custom</option>
        </select>
        <input id="model" class="form-control form-control-sm" style="width: 240px;" placeholder="model (e.g., gpt-4o-mini)" />
        <span id="status" class="badge text-bg-secondary d-none">â€”</span>
        <button class="btn btn-outline-light btn-sm" data-bs-toggle="collapse" data-bs-target="#settings">Settings</button>
        <button id="clearBtn" class="btn btn-sm btn-danger">Clear</button>
      </div>
    </div>
  </nav>

  <div class="container py-3">
    <div class="alert-area" id="alerts"></div>

    <div id="settings" class="collapse">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="mb-3">ðŸ”§ API & Tools</h6>
          <div class="settings-grid">
            <div>
              <label class="form-label">Base URL</label>
              <input id="baseUrl" class="form-control" placeholder="https://api.openai.com" />
            </div>
            <div>
              <label class="form-label">API Key</label>
              <input id="apiKey" type="password" class="form-control" placeholder="sk-..." />
            </div>
            <div>
              <label class="form-label">Google Search API Key</label>
              <input id="googleKey" type="password" class="form-control" placeholder="AIza..." />
            </div>
            <div>
              <label class="form-label">Google CSE CX</label>
              <input id="googleCx" class="form-control" placeholder="custom-search-engine-id" />
            </div>
            <div>
              <label class="form-label">AiPipe Endpoint</label>
              <input id="aipipeUrl" class="form-control" placeholder="https://your-aipipe.example.com/proxy" />
            </div>
            <div>
              <label class="form-label">Max tool loops</label>
              <input id="maxLoops" type="number" value="6" min="1" class="form-control" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="chat" class="mb-2">
      <div class="small-muted mb-2">ðŸ’¡ Tip: ask it to <span class="kbd">search</span>, <span class="kbd">run_js</span>, or call <span class="kbd">aipipe_run</span>.</div>
    </div>

    <div class="sticky-input">
      <div class="divider"></div>
      <div class="input-group">
        <textarea id="userInput" class="form-control" rows="2" placeholder="Type a message and press Enterâ€¦"></textarea>
        <button id="sendBtn" class="btn btn-primary">â–¶ Send</button>
      </div>
      <div class="d-flex justify-content-between mt-2 small-muted">
        <div>
          Provider endpoints are OpenAI-style. For Gemini, use base URL <code class="inline">https://generativelanguage.googleapis.com/openai/</code> with a Google API key.
        </div>
        <div><span class="kbd">Shift+Enter</span> for newline</div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
  // Elements
  const els = {
    chat: document.getElementById('chat'),
    input: document.getElementById('userInput'),
    send: document.getElementById('sendBtn'),
    alerts: document.getElementById('alerts'),
    provider: document.getElementById('provider'),
    baseUrl: document.getElementById('baseUrl'),
    apiKey: document.getElementById('apiKey'),
    model: document.getElementById('model'),
    googleKey: document.getElementById('googleKey'),
    googleCx: document.getElementById('googleCx'),
    aipipeUrl: document.getElementById('aipipeUrl'),
    maxLoops: document.getElementById('maxLoops'),
  };

  // Provider presets
  const PROVIDERS = {
    openai:      { baseUrl: 'https://api.openai.com',                                 model: 'gpt-4o-mini' },
    openrouter:  { baseUrl: 'https://openrouter.ai/api',                              model: 'openai/gpt-4o-mini' },
    perplexity:  { baseUrl: 'https://api.perplexity.ai',                              model: 'llama-3.1-sonar-small-128k-online' },
    gemini:      { baseUrl: 'https://generativelanguage.googleapis.com/openai/',      model: 'gemini-1.5-pro' },
    aipipe:      { baseUrl: 'https://your-aipipe.example.com/openai',                 model: 'gpt-4o-mini' },
    custom:      { baseUrl: '',                                                       model: '' }
  };

  function applyProviderPreset() {
    const p = PROVIDERS[els.provider.value] || {};
    if (!els.baseUrl.value) els.baseUrl.value = p.baseUrl || '';
    if (!els.model.value) els.model.value = p.model || '';
    const badge = document.getElementById('status');
    if (badge) {
      badge.classList.remove('d-none');
      badge.textContent = `${els.provider.value} Â· ${els.model.value || 'model?'}`;
    }
  }
  els.provider.addEventListener('change', () => {
    const p = PROVIDERS[els.provider.value] || {};
    els.baseUrl.value = p.baseUrl || '';
    els.model.value = p.model || '';
    const badge = document.getElementById('status');
    if (badge) {
      badge.classList.remove('d-none');
      badge.textContent = `${els.provider.value} Â· ${els.model.value || 'model?'}`;
    }
  });
  applyProviderPreset();

  // UI helpers
  function showAlert(message, variant = 'warning', timeout = 4500) {
    const id = 'al_' + Math.random().toString(36).slice(2);
    const html = `<div id="${id}" class="alert alert-${variant} alert-dismissible fade show" role="alert">
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>`;
    els.alerts.insertAdjacentHTML('beforeend', html);
    if (timeout) setTimeout(() => {
      const el = document.getElementById(id);
      if (el) bootstrap.Alert.getOrCreateInstance(el).close();
    }, timeout);
  }

  function escapeHtml(str) {
    return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
  }

  function addMsg(role, content, kind = 'agent') {
    const which = kind || (role === 'user' ? 'user' : 'agent');
    const card = document.createElement('div');
    card.className = `card mb-2 msg ${which}`;
    card.innerHTML = `<div class="card-body py-2">${escapeHtml(content)}</div>`;
    els.chat.appendChild(card);
    els.chat.scrollTop = els.chat.scrollHeight;
  }

  function addToolMsg(title, obj) {
    const card = document.createElement('div');
    card.className = 'card mb-2 msg tool';
    const pretty = escapeHtml(JSON.stringify(obj, null, 2));
    card.innerHTML = `<div class="card-body py-2"><div class="small-muted mb-1">${title}</div><pre class="mb-0">${pretty}</pre></div>`;
    els.chat.appendChild(card);
    els.chat.scrollTop = els.chat.scrollHeight;
  }

  function clearChat() {
    messages.splice(1); // keep system
    els.chat.innerHTML = '<div class="small-muted mb-2">ðŸ’¡ Tip: ask it to <span class="kbd">search</span>, <span class="kbd">run_js</span>, or call <span class="kbd">aipipe_run</span>.</div>';
    addMsg('assistant', 'Cleared. Ready.', 'agent');
  }

  // Worker-based JS sandbox
  function runInWorker(code, timeoutMs = 2000) {
    const workerCode = `
      let logs = [];
      const origLog = console.log;
      console.log = (...args) => {
        try { logs.push(args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ')); }
        catch (e) { logs.push(String(args)); }
        origLog(...args);
      };
      onmessage = async (e) => {
        const { code, timeoutMs } = e.data;
        try {
          const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
          const fn = new AsyncFunction(code);
          const exec = fn();
          const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout exceeded')), timeoutMs));
          const started = Date.now();
          const result = await Promise.race([exec, timeout]);
          postMessage({ ok: true, result, logs, timeMs: Date.now() - started });
        } catch (err) {
          postMessage({ ok: false, error: String(err), logs });
        }
      };
    `;
    const blob = new Blob([workerCode], { type: 'text/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));
    return new Promise((resolve) => {
      const timer = setTimeout(() => { try { worker.terminate(); } catch(_){} resolve({ ok: false, error: 'Worker aborted (hard timeout)' }); }, Math.max(timeoutMs + 250, 1500));
      worker.onmessage = (ev) => { clearTimeout(timer); worker.terminate(); resolve(ev.data); };
      worker.postMessage({ code, timeoutMs });
    });
  }

  // OpenAI-style tool specs
  const toolsSpec = [
    {
      type: 'function',
      function: {
        name: 'google_search',
        description: 'Search the web via Google Custom Search and return title, link, snippet. Requires googleKey + googleCx.',
        parameters: {
          type: 'object',
          properties: {
            query: { type: 'string' },
            num: { type: 'integer', minimum: 1, maximum: 10, default: 5 }
          },
          required: ['query']
        }
      }
    },
    {
      type: 'function',
      function: {
        name: 'aipipe_run',
        description: 'Call an AiPipe proxy endpoint with a flow name and payload. Uses aipipeUrl unless overridden.',
        parameters: {
          type: 'object',
          properties: {
            flow: { type: 'string' },
            payload: { type: 'object' },
            endpoint: { type: 'string' }
          },
          required: ['flow', 'payload']
        }
      }
    },
    {
      type: 'function',
      function: {
        name: 'run_js',
        description: 'Execute JavaScript in a sandboxed Worker, return logs and result.',
        parameters: {
          type: 'object',
          properties: {
            code: { type: 'string' },
            timeout_ms: { type: 'integer', default: 2000, minimum: 100 }
          },
          required: ['code']
        }
      }
    }
  ];

  // Conversation state
  const messages = [
    { role: 'system', content: 'You are a browser LLM agent with google_search, aipipe_run, and run_js tools. Decide when to use them. Keep responses concise and mention which tool you used when helpful.' }
  ];

  // Tool implementations
  async function tool_google_search(args) {
    const key = els.googleKey.value.trim();
    const cx = els.googleCx.value.trim();
    if (!key || !cx) throw new Error('Missing Google Search API Key or CSE CX (set in Settings).');
    const num = Math.min(Math.max(parseInt(args.num || 5, 10), 1), 10);
    const url = new URL('https://www.googleapis.com/customsearch/v1');
    url.searchParams.set('key', key);
    url.searchParams.set('cx', cx);
    url.searchParams.set('q', args.query);
    url.searchParams.set('num', String(num));
    const res = await fetch(url.toString());
    if (!res.ok) throw new Error('Google Search error: ' + res.status);
    const data = await res.json();
    const items = (data.items || []).map(it => ({ title: it.title, link: it.link, snippet: it.snippet }));
    return { query: args.query, results: items };
  }

  async function tool_aipipe_run(args) {
    const endpoint = (args.endpoint || els.aipipeUrl.value || '').trim();
    if (!endpoint) throw new Error('Missing AiPipe endpoint URL.');
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ flow: args.flow, payload: args.payload })
    });
    if (!res.ok) {
      const t = await res.text().catch(()=>''); 
      throw new Error('AiPipe error: ' + res.status + (t ? (' ' + t) : ''));
    }
    return await res.json();
  }

  async function tool_run_js(args) {
    const out = await runInWorker(String(args.code || ''), parseInt(args.timeout_ms || 2000, 10));
    return out;
  }

  const TOOL_DISPATCH = { google_search: tool_google_search, aipipe_run: tool_aipipe_run, run_js: tool_run_js };

  // LLM client
  function getClient() {
    const baseUrl = els.baseUrl.value.trim().replace(/\/$/, '');
    const key = els.apiKey.value.trim();
    const model = els.model.value.trim();
    if (!baseUrl || !key || !model) throw new Error('Please set Base URL, API Key, and Model.');
    return { baseUrl, key, model };
  }

  async function chatCompletion(payload) {
    const { baseUrl, key } = getClient();
    const res = await fetch(baseUrl + '/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + key },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const txt = await res.text().catch(()=>'');
      throw new Error('LLM error ' + res.status + ': ' + txt);
    }
    return await res.json();
  }

  async function oneLLMStep() {
    const { model } = getClient();
    const payload = { model, messages, tools: toolsSpec, tool_choice: 'auto' };
    const data = await chatCompletion(payload);
    const choice = (data.choices && data.choices[0]) || {};
    const msg = choice.message || {};
    const content = msg.content || '';
    const toolCalls = msg.tool_calls || [];
    if (content) addMsg('assistant', content, 'agent');
    return toolCalls;
  }

  async function executeToolCalls(toolCalls) {
    const jobs = toolCalls.map(async (tc) => {
      const name = tc.function?.name;
      let args = {};
      try { args = JSON.parse(tc.function?.arguments || '{}'); } catch (_) {}
      try {
        const fn = TOOL_DISPATCH[name];
        if (!fn) throw new Error('Unknown tool: ' + name);
        const result = await fn(args);
        addToolMsg(`Tool: ${name}`, result);
        messages.push({ role: 'tool', tool_call_id: tc.id, content: JSON.stringify(result) });
      } catch (err) {
        const fail = { ok: false, error: String(err) };
        showAlert(`${name} failed: ${String(err)}`, 'danger');
        addToolMsg(`Tool error: ${name}`, fail);
        messages.push({ role: 'tool', tool_call_id: tc.id, content: JSON.stringify(fail) });
      }
    });
    await Promise.all(jobs);
  }

  async function agentLoop() {
    let loops = 0;
    const MAX = Math.max(parseInt(els.maxLoops.value || '6', 10), 1);
    while (true) {
      if (loops++ > MAX) { showAlert('Stopped: reached max tool loops'); break; }
      let toolCalls = [];
      try {
        toolCalls = await oneLLMStep();
      } catch (err) {
        showAlert('LLM step failed: ' + String(err), 'danger', 8000);
        break;
      }
      if (toolCalls && toolCalls.length) {
        await executeToolCalls(toolCalls);
        continue;
      } else {
        break;
      }
    }
  }

  // Input handlers
  async function onSend() {
    const text = els.input.value.trim();
    if (!text) return;
    els.input.value = '';
    addMsg('user', text, 'user');
    messages.push({ role: 'user', content: text });
    await agentLoop();
  }
  els.send.addEventListener('click', onSend);
  els.input.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); onSend(); }});
  document.getElementById('clearBtn').addEventListener('click', clearChat);

  // Seed message
  addMsg('assistant', 'âœ… Ready. Configure Settings, then try: \"Interview me and search for IBM first.\" Tools: google_search, aipipe_run, run_js. Providers: OpenAI, Perplexity, Gemini, OpenRouter, AiPipe.', 'agent');
  </script>
</body>
</html>
